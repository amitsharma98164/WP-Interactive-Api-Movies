{"version":3,"file":"e2e/directive-priorities.js","mappings":"mMASA,MAAMA,EAAkBC,IACvB,MAAMC,EAAKC,SAASC,cAAc,mCAC7BF,EAAGG,YACHH,EAAGG,aAAgB,KAAIJ,IADPC,EAAGG,YAAcJ,CACP,GAShCK,EAAAA,EAAAA,GACC,gBACA,EAAGC,SAAWC,YAAYC,OAASC,gBAClCV,EAAe,WACf,MAAMW,GAAQC,EAAAA,EAAAA,IAAW,CACxBC,UAAW,eACXC,KAAM,iBAEP,OAAO,QAACN,EAAQ,CAACG,MAAOA,EAAM,SAAED,GAAoB,GAErD,CAAEK,SAAU,KAObT,EAAAA,EAAAA,GAAU,kBAAkB,EAAGC,UAASS,WAAUC,cACjDjB,EAAe,aACf,MACMkB,EAAiBF,EAAS,oBAAqB,CACpDT,SAFoBY,EAAAA,EAAAA,IAAWZ,MAIhCa,EAAAA,EAAAA,KAAU,KACTH,EAAQI,IAAIC,QAAQC,aAAa,iBAAkBL,EAAe,GAChE,IACHD,EAAQR,MAAM,kBAAoBS,CAAc,KAOjDZ,EAAAA,EAAAA,GACC,aACA,EAAGC,UAASS,WAAUC,cACrBjB,EAAe,QACf,MACMwB,EAAYR,EAAS,eAAgB,CAC1CT,SAFoBY,EAAAA,EAAAA,IAAWZ,KAIhCU,EAAQR,MAAMC,UAAW,aAAG,cAAY,OAAM,SAAEc,GAAc,GAE/D,CAAET,SAAU,MAQbT,EAAAA,EAAAA,GACC,iBACA,EAAGC,UAASS,WAAUC,cACrBjB,EAAe,YACf,MAAMyB,GAAeN,EAAAA,EAAAA,IAAWZ,GAOhCU,EAAQR,MAAMC,UACb,yBACEO,EAAQR,MAAMC,UACf,kBAAQgB,QATc,KACvBV,EAAS,0BAA2B,CAAET,QAASkB,GAAe,EAQ5B,+BACjC,kBAAQC,QAPS,KAClBV,EAAS,qBAAsB,CAAET,QAASkB,GAAe,EAM5B,2BAE7B,GAEF,CAAEV,SAAU,MAGbY,EAAAA,EAAAA,GAAM,CACLC,QAAS,CACRC,YAAW,QAAEtB,IACZA,EAAQO,KAAO,SAChB,EACAgB,iBAAgB,QAAEvB,IACjBA,EAAQM,UAAY,SACrB,I,8FChGF,MAAMN,GAAUwB,EAAAA,EAAAA,IAAc,CAAC,GAGzBC,EAAe,CAAC,EAChBC,EAAsB,CAAC,EAChB3B,EAAY,CAAC4B,EAAMC,GAAMpB,WAAW,IAAO,CAAC,KACxDiB,EAAaE,GAAQC,EACrBF,EAAoBC,GAAQnB,CAAQ,EAiD/BqB,EAAY,EAAGC,OAAMC,aAAY7B,MAAO8B,MAC7C,MAAMlB,GAAMmB,EAAAA,EAAAA,IAAO,MACbvB,GAAUwB,EAAAA,EAAAA,GAAEJ,EAAM,IAAKE,EAAelB,QACtCL,GAAW0B,EAAAA,EAAAA,KAAQ,IAxCzB,GAAGrB,OAAQ,CAAC,IACZ,CAACsB,EAAMC,EAAY,CAAC,KAEnB,MAAMC,EAAkC,MAAZF,EAAK,OAAiBA,EAAOA,EAAKG,MAAM,IAC9DnC,EAZQ,EAACgC,EAAMI,KACtB,IAAIzB,EAAU,IAAKK,EAAAA,GAAOpB,QAASwC,GAEnC,OADAJ,EAAKK,MAAM,KAAKC,SAASC,GAAO5B,EAAUA,EAAQ4B,KAC3C5B,CAAO,EASC6B,CAAQR,EAAMC,EAAUrC,SAChC6C,EACY,mBAAVzC,EACJA,EAAM,CACNU,IAAKA,EAAIC,WACNK,EAAAA,MACAiB,IAEHjC,EACJ,OAAOkC,GAAuBO,EAAcA,CAAW,EA2BzBC,CAAY,CAAEhC,SAAQ,IAG/CiC,EAzBoBhB,KAC1BI,EAAAA,EAAAA,KAAQ,KACP,MAAMa,EAAaC,OAAOC,QAAQnB,GAAYoB,QAC7C,CAACC,GAAMzB,EAAM0B,MACZ,MAAM7C,EAAWkB,EAAoBC,GAIrC,OAHKyB,EAAI5C,KAAW4C,EAAI5C,GAAY,CAAC,GACrC4C,EAAI5C,GAAUmB,GAAQ0B,EAEfD,CAAG,GAEX,CAAC,GAGF,OAAOH,OAAOC,QAAQF,GACpBM,MAAK,EAAEC,IAAMC,KAAQD,EAAKC,IAC1BC,KAAI,EAAE,CAAEC,KAASA,GAAI,GACrB,CAAC3B,IASoB4B,CAAkB5B,GAC1C,OACC,QAAC6B,EAAsB,CACtB7B,WAAYgB,EACZrC,QAASA,EACTD,SAAUA,EACVuB,cAAeA,GACd,EAKE4B,EAAyB,EAC9B7B,YAAaA,KAAe8B,GAC5BnD,UACAD,WACAuB,oBAMAtB,GAAUoD,EAAAA,EAAAA,IAAapD,GASvB,MAAMP,EACL0D,EAAKE,OAAS,GACb,QAACH,EAAsB,CACtB7B,WAAY8B,EACZnD,QAASA,EACTD,SAAUA,EACVuB,cAAeA,IAGhBtB,EAGIR,EAAQ,IAAK8B,EAAe7B,YAC5B6D,EAAgB,CAAEjC,aAAY7B,QAAOQ,UAASV,UAASS,YAE7D,IAAK,MAAMwD,KAAKlC,EAAY,CAC3B,MAAMmC,EAAUzC,EAAawC,KAAKD,QAClBG,IAAZD,IAAuBhE,EAAMC,SAAW+D,EAC7C,CAEA,OAAOhE,EAAMC,QAAQ,EAIhBiE,EAAMC,EAAAA,GAAAA,MACZA,EAAAA,GAAAA,MAAiBC,IAChB,GAAIA,EAAMpE,MAAMqE,aAAc,CAC7B,MAAMrE,EAAQoE,EAAMpE,MACd6B,EAAa7B,EAAMqE,oBAClBrE,EAAMqE,aACbD,EAAMpE,MAAQ,CACb4B,KAAMwC,EAAMxC,KACZC,aACA7B,SAEDoE,EAAMxC,KAAOD,CACd,CAEIuC,GAAKA,EAAIE,EAAM,C,2FCtIpB,MAAME,EAAYC,GACjBA,GAAwB,iBAATA,IAAsBC,MAAMC,QAAQF,GAEvCG,EAAY,CAACC,EAAQC,KACjC,GAAIN,EAASK,IAAWL,EAASM,GAChC,IAAK,MAAMC,KAAOD,EACbN,EAASM,EAAOC,KACdF,EAAOE,IAAM9B,OAAO+B,OAAOH,EAAQ,CAAE,CAACE,GAAM,CAAC,IAClDH,EAAUC,EAAOE,GAAMD,EAAOC,KAE9B9B,OAAO+B,OAAOH,EAAQ,CAAE,CAACE,GAAMD,EAAOC,IAGzC,EAoBKE,EAjBqB,MAE1B,MAAMC,EAAWtF,SAASC,cACxB,yCAEF,IAAKqF,EAAU,MAAO,CAAC,EACvB,IACC,MAAM,MAAEC,GAAUC,KAAKC,MAAMH,EAASpF,aACtC,GAAI0E,EAASW,GAAQ,OAAOA,EAC5B,MAAMG,MAAM,gCAIb,CAHE,MAAOC,GAERC,QAAQC,IAAIF,EACb,CACA,MAAO,CAAC,CAAC,EAGOG,GACJC,EAAW,CAAER,OAAO9E,EAAAA,EAAAA,IAAW4E,IAEtB,oBAAXW,SAAwBA,OAAOxE,MAAQuE,GAE3C,MAAMvE,EAAQ,EAAG+D,WAAUU,MACjCjB,EAAUe,EAAUE,GACpBjB,EAAUK,EAAUE,EAAM,C","sources":["webpack://__experimentalInteractivity/./e2e/js/directive-priorities.js","webpack://__experimentalInteractivity/./src/runtime/hooks.js","webpack://__experimentalInteractivity/./src/runtime/store.js"],"sourcesContent":["import { useEffect, useContext } from 'preact/hooks';\nimport { deepSignal } from 'deepsignal';\n\nimport { store } from '../../src/runtime/store';\nimport { directive } from '../../src/runtime/hooks';\n\n/**\n * Util to check that render calls happen in order.\n */\nconst executionProof = (n) => {\n\tconst el = document.querySelector('[data-testid=\"execution order\"]');\n\tif (!el.textContent) el.textContent = n;\n\telse el.textContent += `, ${n}`;\n};\n\n/**\n * Simple context directive, just for testing purposes. It provides a deep\n * signal with these two properties:\n * - attribute: 'from context'\n * - text: 'from context'\n */\ndirective(\n\t'test-context',\n\t({ context: { Provider }, props: { children } }) => {\n\t\texecutionProof('context');\n\t\tconst value = deepSignal({\n\t\t\tattribute: 'from context',\n\t\t\ttext: 'from context',\n\t\t});\n\t\treturn <Provider value={value}>{children}</Provider>;\n\t},\n\t{ priority: 8 }\n);\n\n/**\n * Simple attribute directive, for testing purposes. It reads the value of\n * `attribute` from context and populates `data-attribute` with it.\n */\ndirective('test-attribute', ({ context, evaluate, element }) => {\n\texecutionProof('attribute');\n\tconst contextValue = useContext(context);\n\tconst attributeValue = evaluate('context.attribute', {\n\t\tcontext: contextValue,\n\t});\n\tuseEffect(() => {\n\t\telement.ref.current.setAttribute('data-attribute', attributeValue);\n\t}, []);\n\telement.props['data-attribute'] = attributeValue;\n});\n\n/**\n * Simple text directive, for testing purposes. It reads the value of\n * `text` from context and populates `children` with it.\n */\ndirective(\n\t'test-text',\n\t({ context, evaluate, element }) => {\n\t\texecutionProof('text');\n\t\tconst contextValue = useContext(context);\n\t\tconst textValue = evaluate('context.text', {\n\t\t\tcontext: contextValue,\n\t\t});\n\t\telement.props.children = <p data-testid=\"text\">{textValue}</p>;\n\t},\n\t{ priority: 12 }\n);\n\n/**\n * Children directive, for testing purposes. It adds a wrapper around\n * `children`, including two buttons to modify `text` and `attribute` values\n * from the received context.\n */\ndirective(\n\t'test-children',\n\t({ context, evaluate, element }) => {\n\t\texecutionProof('children');\n\t\tconst contextValue = useContext(context);\n\t\tconst updateAttribute = () => {\n\t\t\tevaluate('actions.updateAttribute', { context: contextValue });\n\t\t};\n\t\tconst updateText = () => {\n\t\t\tevaluate('actions.updateText', { context: contextValue });\n\t\t};\n\t\telement.props.children = (\n\t\t\t<div>\n\t\t\t\t{element.props.children}\n\t\t\t\t<button onClick={updateAttribute}>Update attribute</button>\n\t\t\t\t<button onClick={updateText}>Update text</button>\n\t\t\t</div>\n\t\t);\n\t},\n\t{ priority: 14 }\n);\n\nstore({\n\tactions: {\n\t\tupdateText({ context }) {\n\t\t\tcontext.text = 'updated';\n\t\t},\n\t\tupdateAttribute({ context }) {\n\t\t\tcontext.attribute = 'updated';\n\t\t},\n\t},\n});\n","import { h, options, createContext, cloneElement } from 'preact';\nimport { useRef, useMemo } from 'preact/hooks';\nimport { rawStore as store } from './store';\n\n// Main context.\nconst context = createContext({});\n\n// WordPress Directives.\nconst directiveMap = {};\nconst directivePriorities = {};\nexport const directive = (name, cb, { priority = 10 } = {}) => {\n\tdirectiveMap[name] = cb;\n\tdirectivePriorities[name] = priority;\n};\n\n// Resolve the path to some property of the store object.\nconst resolve = (path, ctx) => {\n\tlet current = { ...store, context: ctx };\n\tpath.split('.').forEach((p) => (current = current[p]));\n\treturn current;\n};\n\n// Generate the evaluate function.\nconst getEvaluate =\n\t({ ref } = {}) =>\n\t(path, extraArgs = {}) => {\n\t\t// If path starts with !, remove it and save a flag.\n\t\tconst hasNegationOperator = path[0] === '!' && !!(path = path.slice(1));\n\t\tconst value = resolve(path, extraArgs.context);\n\t\tconst returnValue =\n\t\t\ttypeof value === 'function'\n\t\t\t\t? value({\n\t\t\t\t\t\tref: ref.current,\n\t\t\t\t\t\t...store,\n\t\t\t\t\t\t...extraArgs,\n\t\t\t\t  })\n\t\t\t\t: value;\n\t\treturn hasNegationOperator ? !returnValue : returnValue;\n\t};\n\n// Separate directives by priority. The resulting array contains objects\n// of directives grouped by same priority, and sorted in ascending order.\nconst usePriorityLevels = (directives) =>\n\tuseMemo(() => {\n\t\tconst byPriority = Object.entries(directives).reduce(\n\t\t\t(acc, [name, values]) => {\n\t\t\t\tconst priority = directivePriorities[name];\n\t\t\t\tif (!acc[priority]) acc[priority] = {};\n\t\t\t\tacc[priority][name] = values;\n\n\t\t\t\treturn acc;\n\t\t\t},\n\t\t\t{}\n\t\t);\n\n\t\treturn Object.entries(byPriority)\n\t\t\t.sort(([p1], [p2]) => p1 - p2)\n\t\t\t.map(([, obj]) => obj);\n\t}, [directives]);\n\n// Directive wrapper.\nconst Directive = ({ type, directives, props: originalProps }) => {\n\tconst ref = useRef(null);\n\tconst element = h(type, { ...originalProps, ref });\n\tconst evaluate = useMemo(() => getEvaluate({ ref }), []);\n\n\t// Add wrappers recursively for each priority level.\n\tconst byPriorityLevel = usePriorityLevels(directives);\n\treturn (\n\t\t<RecursivePriorityLevel\n\t\t\tdirectives={byPriorityLevel}\n\t\t\telement={element}\n\t\t\tevaluate={evaluate}\n\t\t\toriginalProps={originalProps}\n\t\t/>\n\t);\n};\n\n// Priority level wrapper.\nconst RecursivePriorityLevel = ({\n\tdirectives: [directives, ...rest],\n\telement,\n\tevaluate,\n\toriginalProps,\n}) => {\n\t// This element needs to be a fresh copy so we are not modifying an already\n\t// rendered element with Preact's internal properties initialized. This\n\t// prevents an error with changes in `element.props.children` not being\n\t// reflected in `element.__k`.\n\telement = cloneElement(element);\n\n\t// Recursively render the wrapper for the next priority level.\n\t//\n\t// Note that, even though we're instantiating a vnode with a\n\t// `RecursivePriorityLevel` here, its render function will not be executed\n\t// just yet. Actually, it will be delayed until the current render function\n\t// has finished. That ensures directives in the current priorty level have\n\t// run (and thus modified the passed `element`) before the next level.\n\tconst children =\n\t\trest.length > 0 ? (\n\t\t\t<RecursivePriorityLevel\n\t\t\t\tdirectives={rest}\n\t\t\t\telement={element}\n\t\t\t\tevaluate={evaluate}\n\t\t\t\toriginalProps={originalProps}\n\t\t\t/>\n\t\t) : (\n\t\t\telement\n\t\t);\n\n\tconst props = { ...originalProps, children };\n\tconst directiveArgs = { directives, props, element, context, evaluate };\n\n\tfor (const d in directives) {\n\t\tconst wrapper = directiveMap[d]?.(directiveArgs);\n\t\tif (wrapper !== undefined) props.children = wrapper;\n\t}\n\n\treturn props.children;\n};\n\n// Preact Options Hook called each time a vnode is created.\nconst old = options.vnode;\noptions.vnode = (vnode) => {\n\tif (vnode.props.__directives) {\n\t\tconst props = vnode.props;\n\t\tconst directives = props.__directives;\n\t\tdelete props.__directives;\n\t\tvnode.props = {\n\t\t\ttype: vnode.type,\n\t\t\tdirectives,\n\t\t\tprops,\n\t\t};\n\t\tvnode.type = Directive;\n\t}\n\n\tif (old) old(vnode);\n};\n","import { deepSignal } from 'deepsignal';\n\nconst isObject = (item) =>\n\titem && typeof item === 'object' && !Array.isArray(item);\n\nexport const deepMerge = (target, source) => {\n\tif (isObject(target) && isObject(source)) {\n\t\tfor (const key in source) {\n\t\t\tif (isObject(source[key])) {\n\t\t\t\tif (!target[key]) Object.assign(target, { [key]: {} });\n\t\t\t\tdeepMerge(target[key], source[key]);\n\t\t\t} else {\n\t\t\t\tObject.assign(target, { [key]: source[key] });\n\t\t\t}\n\t\t}\n\t}\n};\n\nconst getSerializedState = () => {\n\t// TODO: change the store tag ID for a better one.\n\tconst storeTag = document.querySelector(\n\t\t`script[type=\"application/json\"]#store`\n\t);\n\tif (!storeTag) return {};\n\ttry {\n\t\tconst { state } = JSON.parse(storeTag.textContent);\n\t\tif (isObject(state)) return state;\n\t\tthrow Error('Parsed state is not an object');\n\t} catch (e) {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.log(e);\n\t}\n\treturn {};\n};\n\nconst rawState = getSerializedState();\nexport const rawStore = { state: deepSignal(rawState) };\n\nif (typeof window !== 'undefined') window.store = rawStore;\n\nexport const store = ({ state, ...block }) => {\n\tdeepMerge(rawStore, block);\n\tdeepMerge(rawState, state);\n};\n"],"names":["executionProof","n","el","document","querySelector","textContent","directive","context","Provider","props","children","value","deepSignal","attribute","text","priority","evaluate","element","attributeValue","useContext","useEffect","ref","current","setAttribute","textValue","contextValue","onClick","store","actions","updateText","updateAttribute","createContext","directiveMap","directivePriorities","name","cb","Directive","type","directives","originalProps","useRef","h","useMemo","path","extraArgs","hasNegationOperator","slice","ctx","split","forEach","p","resolve","returnValue","getEvaluate","byPriorityLevel","byPriority","Object","entries","reduce","acc","values","sort","p1","p2","map","obj","usePriorityLevels","RecursivePriorityLevel","rest","cloneElement","length","directiveArgs","d","wrapper","undefined","old","options","vnode","__directives","isObject","item","Array","isArray","deepMerge","target","source","key","assign","rawState","storeTag","state","JSON","parse","Error","e","console","log","getSerializedState","rawStore","window","block"],"sourceRoot":""}